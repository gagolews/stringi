# stri\_sub: Extract a Substring From or Replace a Substring In a Character Vector

## Description

`stri_sub` extracts particular substrings at code point-based index ranges provided. Its replacement version allows to substitute (in-place) parts of a string with given replacement strings. `stri_sub_replace` is its forward pipe operator-friendly variant that returns a copy of the input vector.

For extracting/replacing multiple substrings from/within each string, see [`stri_sub_all`](stri_sub_all.md).

## Usage

```r
stri_sub(str, from = 1L, to = -1L, length)

stri_sub(str, from=1L, to=-1L, length, omit_na=FALSE) <- value

stri_sub_replace(..., replacement, value = replacement)
```

## Arguments

|               |                                                                                                                                                                           |
|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `str`         | a character vector                                                                                                                                                        |
| `from`        | an integer vector giving the start indexes or a two-column matrix of type `cbind(from, to)`                                                                               |
| `to`          | an integer vector giving the end indexes; mutually exclusive with `length` and `from` being a matrix                                                                      |
| `length`      | an integer vector giving the substring lengths; mutually exclusive with `to` and `from` being a matrix                                                                    |
| `omit_na`     | a single logical value; indicates whether missing values in any of the indexes or in `value` leave the corresponding input string unchanged \[replacement function only\] |
| `value`       | a character vector defining the replacement strings \[replacement function only\]                                                                                         |
| `...`         | arguments to be passed to `stri_sub<-`                                                                                                                                    |
| `replacement` | alias of `value` \[wherever applicable\]                                                                                                                                  |

## Details

Vectorized over `str`, \[`value`\], `from` and (`to` or `length`). Parameters `to` and `length` are mutually exclusive.

Indexes are 1-based, i.e., the start of a string is at index 1. For negative indexes in `from` or `to`, counting starts at the end of the string. For instance, index -1 denotes the last code point in the string. Non-positive `length` gives an empty string.

Argument `from` gives the start of a substring to extract. Argument `to` defines the last index of a substring, inclusive. Alternatively, its `length` may be provided.

If `from` is a two-column matrix, then these two columns are used as `from` and `to`, respectively, and anything passed explicitly as `from` or `to` is ignored. Such types of index matrices are generated by [`stri_locate_first`](stri_locate.md) and [`stri_locate_last`](stri_locate.md). If extraction based on [`stri_locate_all`](stri_locate.md) is needed, see [`stri_sub_all`](stri_sub_all.md).

In `stri_sub`, out-of-bound indexes are silently corrected. If `from` \> `to`, then an empty string is returned.

In `stri_sub<-`, some configurations of indexes may work as substring \'injection\' at the front, back, or in middle.

If both `to` and `length` are provided, `length` has priority over `to`.

Note that for some Unicode strings, the extracted substrings might not be well-formed, especially if input strings are not NFC-normalized (see [`stri_trans_nfc`](stri_trans_nf.md)), include byte order marks, Bidirectional text marks, and so on. Handle with care.

## Value

`stri_sub` and `stri_sub_replace` return a character vector. `stri_sub<-` changes the `str` object in-place.

## Author(s)

[Marek Gagolewski](https://www.gagolewski.com/) and other contributors

## See Also

The official online manual of <span class="pkg">stringi</span> at <https://stringi.gagolewski.com/>

Other indexing: [`stri_locate_all_boundaries()`](stri_locate_boundaries.md), [`stri_locate_all()`](stri_locate.md), [`stri_sub_all()`](stri_sub_all.md)

## Examples




```r
s <- 'Lorem ipsum dolor sit amet, consectetur adipisicing elit.'
stri_sub(s, from=1:3*6, to=21)
## [1] " ipsum dolor sit" " dolor sit"       " sit"
stri_sub(s, from=c(1,7,13), length=5)
## [1] "Lorem" "ipsum" "dolor"
stri_sub(s, from=1, length=1:3)
## [1] "L"   "Lo"  "Lor"
stri_sub(s, -17, -7)
## [1] "adipisicing"
stri_sub(s, -5, length=4)
## [1] "elit"
(stri_sub(s, 1, 5) <- 'stringi')
## [1] "stringi"
(stri_sub(s, -6, length=5) <- '.')
## [1] "."
(stri_sub(s, 1, 1:3) <- 1:2)
## Warning in `stri_sub<-`(`*tmp*`, 1, 1:3, value = 1:2): longer object length is
## not a multiple of shorter object length
## [1] 1 2
x <- c('12 3456 789', 'abc', '', NA, '667')
stri_sub(x, stri_locate_first_regex(x, '[0-9]+')) # see stri_extract_first
## [1] "12"  NA    NA    NA    "667"
stri_sub(x, stri_locate_last_regex(x, '[0-9]+'))  # see stri_extract_last
## [1] "789" NA    NA    NA    "667"
stri_sub_replace(x, stri_locate_first_regex(x, '[0-9]+'),
    omit_na=TRUE, replacement='***') # see stri_replace_first
## [1] "*** 3456 789" "abc"          ""             NA             "***"
stri_sub_replace(x, stri_locate_last_regex(x, '[0-9]+'),
    omit_na=TRUE, replacement='***') # see stri_replace_last
## [1] "12 3456 ***" "abc"         ""            NA            "***"
stri_sub(x, stri_locate_first_regex(x, '[0-9]+'), omit_na=TRUE) <- '***'
print(x)
## [1] "*** 3456 789" "abc"          ""             NA             "***"
# to fetch first code points of at most a given width, use stri_sprintf:
x <- "\u200b\u200b\u200b\u200b\U0001F3F4\U000E0067\U000E0062\U000E0073\U000E0063\U000E0074\U000E007Fabcd"
stri_sprintf("%.*s", 0:8, x)
## [1] "â€‹â€‹â€‹â€‹"       "â€‹â€‹â€‹â€‹"       "â€‹â€‹â€‹â€‹ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿"     "â€‹â€‹â€‹â€‹ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿a"    "â€‹â€‹â€‹â€‹ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿ab"   "â€‹â€‹â€‹â€‹ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿abc"  "â€‹â€‹â€‹â€‹ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿abcd" "â€‹â€‹â€‹â€‹ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿abcd"
## [9] "â€‹â€‹â€‹â€‹ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿abcd"
## Not run: x %>% stri_sub_replace(1, 5, replacement='new_substring')
```
