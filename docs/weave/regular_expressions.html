<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Collation" href="collation.html" /><link rel="prev" title="Code-Pointwise Comparing" href="codepoint_comparing.html" />
        <link rel="canonical" href="https://stringi.gagolewski.com/weave/regular_expressions.html" />

    <link rel="shortcut icon" href="https://www.gagolewski.com/_static/img/stringi.png"/><!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>Regular Expressions - R Package stringi</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=1981fb80" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">R Package stringi</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto colour theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky">
<div class="sidebar-logo-container">
  <a class="sidebar-brand" href="../index.html"><img class="sidebar-logo" src="https://www.gagolewski.com/_static/img/stringi.png" alt="Logo"/></a>
</div>

<span class="sidebar-brand-text">
<a class="sidebar-brand" href="../index.html">stringi</a>
</span>
<div class="sidebar-brand">
1.8.6
</div>
<form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">stringi</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">About</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com/">Author</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing <em>stringi</em></a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/stringi">Source Code (GitHub)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/stringi/issues">Bug Tracker and Feature Suggestions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cran.r-project.org/package=stringi">CRAN Entry</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="design_principles.html">General Design Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_operations.html">Basic String Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="codepoint_comparing.html">Code-Pointwise Comparing</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Regular Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="collation.html">Collation</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_operations.html">Other Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_output.html">Input and Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="example.html">Example Use Case: Data Preparation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../rapi.html">R Package <em>stringi</em> Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of R Package stringi Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_arguments.html">about_arguments:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_encoding.html">about_encoding:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_locale.html">about_locale:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_boundaries.html">about_search_boundaries:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_charclass.html">about_search_charclass:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_coll.html">about_search_coll:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_fixed.html">about_search_fixed:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_regex.html">about_search_regex:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search.html">about_search: String Searching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/operator_add.html">operator_add: Concatenate Two Character Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/operator_compare.html">operator_compare: Compare Strings with or without Collation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/operator_dollar.html">operator_dollar: as a Binary Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_compare.html">stri_compare: Compare Strings with or without Collation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_count_boundaries.html">stri_count_boundaries: Count the Number of Text Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_count.html">stri_count: Count the Number of Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_add.html">stri_datetime_add: Date and Time Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_create.html">stri_datetime_create: Create a Date-Time Object</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_fields.html">stri_datetime_fields: Get Values for Date and Time Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_format.html">stri_datetime_format: Date and Time Formatting and Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_fstr.html">stri_datetime_fstr: -Style Format Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_now.html">stri_datetime_now: Get Current Date and Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_symbols.html">stri_datetime_symbols: List Localizable Date-Time Formatting Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_detect.html">stri_detect: Detect Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_dup.html">stri_dup: Duplicate Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_duplicated.html">stri_duplicated: Determine Duplicated Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_detect.html">stri_enc_detect: Detect Character Set and Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_detect2.html">stri_enc_detect2: [DEPRECATED] Detect Locale-Sensitive Character Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_fromutf32.html">stri_enc_fromutf32: Convert From UTF-32</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_info.html">stri_enc_info: Query a Character Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_isascii.html">stri_enc_isascii: Check If a Data Stream Is Possibly in ASCII</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_isutf16.html">stri_enc_isutf16: Check If a Data Stream Is Possibly in UTF-16 or UTF-32</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_isutf8.html">stri_enc_isutf8: Check If a Data Stream Is Possibly in UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_list.html">stri_enc_list: List Known Character Encodings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_mark.html">stri_enc_mark: Get Declared Encodings of Each String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_set.html">stri_enc_set:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_toascii.html">stri_enc_toascii: Convert To ASCII</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_tonative.html">stri_enc_tonative: Convert Strings To Native Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_toutf32.html">stri_enc_toutf32: Convert Strings To UTF-32</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_toutf8.html">stri_enc_toutf8: Convert Strings To UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_encode.html">stri_encode: Convert Strings Between Given Encodings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_escape_unicode.html">stri_escape_unicode: Escape Unicode Code Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_extract_boundaries.html">stri_extract_boundaries: Extract Data Between Text Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_extract.html">stri_extract: Extract Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_flatten.html">stri_flatten: Flatten a String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_info.html">stri_info:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_isempty.html">stri_isempty: Determine if a String is of Length Zero</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_join_list.html">stri_join_list: Concatenate Strings in a List</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_join.html">stri_join: Concatenate Character Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_length.html">stri_length: Count the Number of Code Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_list2matrix.html">stri_list2matrix: Convert a List to a Character Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locale_info.html">stri_locale_info: Query Given Locale</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locale_list.html">stri_locale_list: List Available Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locale_set.html">stri_locale_set:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locate_boundaries.html">stri_locate_boundaries: Locate Text Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locate.html">stri_locate: Locate Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_match.html">stri_match: Extract Regex Pattern Matches, Together with Capture Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_na2empty.html">stri_na2empty: Replace NAs with Empty Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_numbytes.html">stri_numbytes: Count the Number of Bytes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_opts_brkiter.html">stri_opts_brkiter: Generate a List with BreakIterator Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_opts_collator.html">stri_opts_collator: Generate a List with Collator Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_opts_fixed.html">stri_opts_fixed: Generate a List with Fixed Pattern Search Engine’s Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_opts_regex.html">stri_opts_regex: Generate a List with Regex Matcher Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_order.html">stri_order: Ordering Permutation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_pad.html">stri_pad: Pad (Center/Left/Right Align) a String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_rand_lipsum.html">stri_rand_lipsum: A Lorem Ipsum Generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_rand_shuffle.html">stri_rand_shuffle: Randomly Shuffle Code Points in Each String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_rand_strings.html">stri_rand_strings: Generate Random Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_rank.html">stri_rank: Ranking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_read_lines.html">stri_read_lines: Read Text Lines from a Text File</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_read_raw.html">stri_read_raw: Read Text File as Raw</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_remove_empty.html">stri_remove_empty: Remove All Empty Strings from a Character Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_replace_na.html">stri_replace_na: Replace Missing Values in a Character Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_replace_rstr.html">stri_replace_rstr: Convert gsub-Style Replacement Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_replace.html">stri_replace: Replace Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_reverse.html">stri_reverse: Reverse Each String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sort_key.html">stri_sort_key: Sort Keys</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sort.html">stri_sort: String Sorting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_split_boundaries.html">stri_split_boundaries: Split a String at Text Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_split_lines.html">stri_split_lines: Split a String Into Text Lines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_split.html">stri_split: Split a String By Pattern Matches</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sprintf.html">stri_sprintf: Format Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_startsendswith.html">stri_startsendswith: Determine if the Start or End of a String Matches a Pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_stats_general.html">stri_stats_general: General Statistics for a Character Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_stats_latex.html">stri_stats_latex: Statistics for a Character Vector Containing LaTeX Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sub_all.html">stri_sub_all: Extract or Replace Multiple Substrings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sub.html">stri_sub: Extract a Substring From or Replace a Substring In a Character Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_subset.html">stri_subset: Select Elements that Match a Given Pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_timezone_info.html">stri_timezone_info: Query a Given Time Zone</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_timezone_list.html">stri_timezone_list: List Available Time Zone Identifiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_timezone_set.html">stri_timezone_set:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_casemap.html">stri_trans_casemap: Transform Strings with Case Mapping or Folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_char.html">stri_trans_char: Translate Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_general.html">stri_trans_general: General Text Transforms, Including Transliteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_list.html">stri_trans_list: List Available Text Transforms and Transliterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_nf.html">stri_trans_nf: Perform or Check For Unicode Normalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trim.html">stri_trim: Trim Characters from the Left and/or Right Side of a String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_unescape_unicode.html">stri_unescape_unicode: Un-escape All Escape Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_unique.html">stri_unique: Extract Unique Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_width.html">stri_width: Determine the Width of Code Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_wrap.html">stri_wrap: Word Wrap Text to Format Paragraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_write_lines.html">stri_write_lines: Write Text Lines to a Text File</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stringi-package.html">stringi-package: Fast and Portable Character String Processing in R</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://deepr.gagolewski.com/">Deep R Programming</a></li>
<li class="toctree-l1"><a class="reference external" href="https://stringx.gagolewski.com/">stringx</a></li>
<li class="toctree-l1"><a class="reference external" href="https://dx.doi.org/10.18637/jss.v103.i02">JStatSoft Paper</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/ExampleRcppStringi">C++ API — Rcpp Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../news.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../z_bibliography.html">References</a></li>
</ul>

</div></div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/gagolews/stringi/issues/" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto colour theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="regular-expressions">
<span id="sec-regex"></span><h1>Regular Expressions<a class="headerlink" href="#regular-expressions" title="Link to this heading">¶</a></h1>
<blockquote>
<div><p>This tutorial is based on the <a class="reference external" href="https://dx.doi.org/10.18637/jss.v103.i02">paper on <em>stringi</em></a> that was published in the <em>Journal of Statistical Software</em>; see <span id="id1">[<a class="reference internal" href="../z_bibliography.html#id3" title="Gagolewski, M. (2022).  stringi: Fast and portable character string processing in R. Journal of Statistical Software, 103(2):1–59. DOI: 10.18637/jss.v103.i02.">2</a>]</span>. To learn more about R, check out Marek’s open-access (free!) textbook <a class="reference external" href="https://deepr.gagolewski.com/"><em>Deep R Programming</em></a> <span id="id2">[<a class="reference internal" href="../z_bibliography.html#id4" title="Gagolewski, M. (2023).  Deep R Programming. Zenodo, Melbourne. ISBN 978-0-6455719-2-9. URL: https://deepr.gagolewski.com/, DOI: 10.5281/zenodo.7490464.">3</a>]</span>.</p>
</div></blockquote>
<p>Regular expressions (regexes) provide concise grammar for
defining systematic patterns that can be sought in character strings.
Examples of such patterns include: specific fixed substrings, emojis of
any kind, stand-alone sequences of lower-case Latin letters (“words”),
substrings that can be interpreted as real numbers (with or without
fractional parts, also in scientific notation), telephone numbers, email
addresses, or URLs.</p>
<p>Theoretically, the concept of regular pattern matching dates back to the
so-called regular languages and finite state automata <span id="id3">[<a class="reference internal" href="../z_bibliography.html#id26" title="Kleene, S.C. (1951).  Representation of events in nerve nets and finite automata. Technical Report RM-704, The RAND Corporation, Santa Monica, CA. URL https://www.rand.org/content/dam/rand/pubs/research_memoranda/2008/RM704.pdf.">6</a>]</span>, see
also <span id="id4">[<a class="reference internal" href="../z_bibliography.html#id29" title="Hopcroft, J.E. and Ullman, J.D. (1979).  Introduction to Automata Theory, Languages, and Computation. Addison-Wesley.">5</a>]</span> and <span id="id5">[<a class="reference internal" href="../z_bibliography.html#id27" title="Rabin, M. and Scott, D. (1959).  Finite automata and their decision problems. IBM Journal of Research and Development, 3:114–125.">9</a>]</span>. Regexes in the form
as we know it today
have already been present in one of the pre-Unix implementations of the
command-line text editor <em>qed</em> (<span id="id6">[<a class="reference internal" href="../z_bibliography.html#id28" title="Ritchie, D.M. and Thompson, K.L. (1970).  QED text editor. Technical Report 70107-002, Bell Telephone Laboratories, Inc. URL: https://wayback.archive-it.org/all/20150203071645/http://cm.bell-labs.com/cm/cs/who/dmr/qedman.pdf.">10</a>]</span>; the predecessor of the
well-known <em>sed</em>).</p>
<p>Base R gives access to two different regex matching engines (via
functions such as <code class="docutils literal notranslate"><span class="pre">gregexpr()</span></code> and <code class="docutils literal notranslate"><span class="pre">grep()</span></code>):</p>
<ul class="simple">
<li><p>ERE (extended regular expressions that conform to the
POSIX.2-1992 standard;
via the <a class="reference external" href="https://github.com/laurikari/tre/"><em>TRE</em></a> library);
used by default,</p></li>
<li><p>PCRE (Perl-compatible regular expressions;
via the <a class="reference external" href="https://www.pcre.org/"><em>PCRE2</em></a> library);
activated when <code class="docutils literal notranslate"><span class="pre">perl=TRUE</span></code> is set.</p></li>
</ul>
<p>Other matchers are implemented in the <a class="reference external" href="https://CRAN.R-project.org/package=ore"><em>ore</em></a>, <a class="reference external" href="https://github.com/qinwf/re2r"><em>re2r</em></a>,
and <a class="reference external" href="https://github.com/girishji/re2/"><em>re2</em></a> packages.</p>
<p><em>Stringi</em>, on the other hand, provides access to the regex engine
implemented in <a class="reference external" href="https://icu.unicode.org/"><em>ICU</em></a>,
which was inspired by Java’s <em>util.regex</em> in
<em>JDK 1.4</em>. Their syntax is mostly compatible with that of <em>PCRE</em>, although
certain more advanced facets might not be supported (e.g., recursive
patterns). On the other hand, <em>ICU</em> regexes fully conform to the
<a class="reference external" href="https://www.unicode.org/reports/tr18/">Unicode Technical Standard #18</a>
and hence provide comprehensive support for Unicode.</p>
<p>It is worth noting that most programming languages and advanced
text editors and development environments
(including <a class="reference external" href="https://kate-editor.org/"><em>Kate</em></a>,
<a class="reference external" href="https://www.eclipse.org/ide/"><em>Eclipse</em></a>,
<a class="reference external" href="https://code.visualstudio.com/"><em>VSCode</em></a>,
and <a class="reference external" href="https://www.rstudio.com/products/rstudio/"><em>RStudio</em></a>) support finding or replacing patterns with
regexes. Therefore, they should be amongst the instruments at every data
scientist’s disposal. One general introduction to regexes is <span id="id7">[<a class="reference internal" href="../z_bibliography.html#id25" title="Friedl, J.E.F. (2006).  Mastering Regular Expressions. O'Reilly.">1</a>]</span>.
The <em>ICU</em> flavour is summarised at
<a class="reference external" href="https://unicode-org.github.io/icu/userguide/strings/regexp.html">https://unicode-org.github.io/icu/userguide/strings/regexp.html</a>.</p>
<p>Below we provide a concise yet comprehensive introduction to the topic
from the perspective of the <em>stringi</em> package users. This time we will
use the pattern search routines whose names end with the <code class="docutils literal notranslate"><span class="pre">*_regex()</span></code>
suffix. Apart from <code class="docutils literal notranslate"><span class="pre">stri_detect_regex()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_locate_all_regex()</span></code>, and
so forth, in <a class="reference internal" href="#sec-capturing"><span class="std std-ref">Capture Groups and References Thereto</span></a> we introduce <code class="docutils literal notranslate"><span class="pre">stri_match_all_regex()</span></code>.
Moreover, the table below lists the available options for the regex
engine.</p>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Option</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">case_insensitive</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether to enable (full) case-insensitive matching</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">comments</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether to allow white spaces and comments within patterns</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dot_all</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; if set, “<code class="docutils literal notranslate"><span class="pre">.</span></code>” matches line terminators; otherwise its matching stops at a line end</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">literal</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether to treat the entire pattern as a literal string; note that in most cases the code-pointwise string search facilities (<code class="docutils literal notranslate"><span class="pre">*_fixed()</span></code> functions described in <a class="reference internal" href="codepoint_comparing.html#sec-fixed"><span class="std std-ref">Code-Pointwise Comparing</span></a> are faster</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">multi_line</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; if set, “<code class="docutils literal notranslate"><span class="pre">$</span></code>” and “<code class="docutils literal notranslate"><span class="pre">^</span></code>” recognise line terminators within a string; otherwise, they match only at start and end of the input</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">unix_lines</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; when enabled, only the Unix line ending, i.e., U+000A, is honoured as a terminator by “<code class="docutils literal notranslate"><span class="pre">.</span></code>”, “<code class="docutils literal notranslate"><span class="pre">$</span></code>”, and “<code class="docutils literal notranslate"><span class="pre">^</span></code>”</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">uword</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether to use the Unicode definition of word boundaries (see <a class="reference internal" href="other_operations.html#sec-boundaryanalysis"><span class="std std-ref">Analysing Text Boundaries</span></a>), which are quite different from the traditional regex word boundaries</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">error_on_unknown_escapes</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether unrecognised backslash-escaped characters trigger an error; by default, unknown backslash-escaped ASCII letters represent themselves</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">time_limit</span></code></p></td>
<td><p>integer; processing time limit for match operations in ~milliseconds (depends on the CPU speed); 0 for no limit (the default)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stack_limit</span></code></p></td>
<td><p>integer; maximal size, in bytes, of the heap storage available for the matcher’s backtracking stack; setting a limit is desirable if poorly written regexes are expected on input; 0 for no limit (the default)</p></td>
</tr>
</tbody>
</table>
</div>
<section id="matching-individual-characters">
<span id="sec-regexindividualchars"></span><h2>Matching Individual Characters<a class="headerlink" href="#matching-individual-characters" title="Link to this heading">¶</a></h2>
<p>We begin by discussing different ways to define character sets. In this
part, determining the length of all matching substrings will be quite
straightforward.</p>
<p>The following characters have special meaning to the regex engine:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">.</span></code>
<code class="docutils literal notranslate"><span class="pre">\</span></code>
<code class="docutils literal notranslate"><span class="pre">|</span></code>
<code class="docutils literal notranslate"><span class="pre">(</span></code>
<code class="docutils literal notranslate"><span class="pre">)</span></code>
<code class="docutils literal notranslate"><span class="pre">[</span></code>
<code class="docutils literal notranslate"><span class="pre">{</span></code>
<code class="docutils literal notranslate"><span class="pre">}</span></code>
<code class="docutils literal notranslate"><span class="pre">^</span></code>
<code class="docutils literal notranslate"><span class="pre">$</span></code>
<code class="docutils literal notranslate"><span class="pre">*</span></code>
<code class="docutils literal notranslate"><span class="pre">+</span></code>
<code class="docutils literal notranslate"><span class="pre">?</span></code></p>
</div></blockquote>
<p>Any regular expression that doesn’t contain the above behaves like a
fixed pattern:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_regex</span><span class="p">(</span><span class="s">&quot;spam, eggs, spam, bacon, sausage, and spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam&quot;</span><span class="p">)</span>
<span class="c1">## [1] 3</span>
</pre></div>
</div>
<p>There are hence 3 occurrences of a pattern that is comprised of 4 code
points, “<code class="docutils literal notranslate"><span class="pre">s</span></code>” followed by “<code class="docutils literal notranslate"><span class="pre">p</span></code>”, then by “<code class="docutils literal notranslate"><span class="pre">a</span></code>”, and ending with “<code class="docutils literal notranslate"><span class="pre">m</span></code>”.</p>
<p>However, this time the case insensitive mode fully supports Unicode
matching<a class="footnote-reference brackets" href="#footequivalent" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_detect_regex</span><span class="p">(</span><span class="s">&quot;groß&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;GROSS&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [1] TRUE</span>
</pre></div>
</div>
<p>If we wish to include a special character as part of a regular
expression – so that it is treated literally – we’ll need to escape
it with a backslash, “&quot;. Yet, the backlash itself has a special
meaning to R, see <code class="docutils literal notranslate"><span class="pre">help(&quot;Quotes&quot;)</span></code>. Therefore it needs to be preceded by
another backslash.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_regex</span><span class="p">(</span><span class="s">&quot;spam...&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\.&quot;</span><span class="p">)</span><span class="w">   </span><span class="c1"># &quot;\\&quot; is a way to input a single \</span>
<span class="c1">## [1] 3</span>
</pre></div>
</div>
<p>In other words, the R string <code class="docutils literal notranslate"><span class="pre">&quot;\\.&quot;</span></code> is seen by the regex engine as
“<code class="docutils literal notranslate"><span class="pre">\.</span></code>” and interpreted as the dot character (literally). Alternatively,
since R 4.0 we can also input the so-called literal strings like
<code class="docutils literal notranslate"><span class="pre">r&quot;(\.)&quot;</span></code>.</p>
<section id="matching-any-character">
<h3>Matching Any Character<a class="headerlink" href="#matching-any-character" title="Link to this heading">¶</a></h3>
<p>The (unescaped) dot, “<code class="docutils literal notranslate"><span class="pre">.</span></code>”, matches any code point except the newline.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;Spam, ham,\njam, SPAM, eggs, and spam&quot;</span>
<span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;..am&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;Spam&quot; &quot; ham&quot; &quot;SPAM&quot; &quot;spam&quot;</span>
</pre></div>
</div>
<p>The above matches non-overlapping length-4 substrings that end with
“<code class="docutils literal notranslate"><span class="pre">am</span></code>”.</p>
<p>The dot’s insensitivity to the newline character is motivated by the
need to maintain compatibility with tools such as <em>grep</em> (when
searching within text files in a line-by-line manner). This behaviour
can be altered by setting the <code class="docutils literal notranslate"><span class="pre">dot_all</span></code> option to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;..am&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">dot_all</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;Spam&quot;  &quot; ham&quot;  &quot;\njam&quot; &quot;SPAM&quot;  &quot;spam&quot;</span>
</pre></div>
</div>
</section>
<section id="defining-character-sets">
<h3>Defining Character Sets<a class="headerlink" href="#defining-character-sets" title="Link to this heading">¶</a></h3>
<p>Sets of characters can be introduced by enumerating their members within
a pair of square brackets. For instance, “<code class="docutils literal notranslate"><span class="pre">[abc]</span></code>” denotes the set
<span class="math notranslate nohighlight">\(\{\mathtt{a},\mathtt{b},\mathtt{c}\}\)</span> – such a regular expression
matches one (and only one) symbol from this set. Moreover, in:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[hj]am&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;ham&quot; &quot;jam&quot;</span>
</pre></div>
</div>
<p>the “<code class="docutils literal notranslate"><span class="pre">[hj]am</span></code>” regex matches: “<code class="docutils literal notranslate"><span class="pre">h</span></code>” or “<code class="docutils literal notranslate"><span class="pre">j</span></code>”, followed by “<code class="docutils literal notranslate"><span class="pre">a</span></code>”,
followed by “<code class="docutils literal notranslate"><span class="pre">m</span></code>”. In other words, <code class="docutils literal notranslate"><span class="pre">&quot;ham&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;jam&quot;</span></code> are the only two
strings that are matched by this pattern (unless matching is done
case-insensitively).</p>
<p>The following characters, if used within square brackets, may be treated
non-literally:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">\</span></code>
<code class="docutils literal notranslate"><span class="pre">[</span></code>
<code class="docutils literal notranslate"><span class="pre">]</span></code>
<code class="docutils literal notranslate"><span class="pre">^</span></code>
<code class="docutils literal notranslate"><span class="pre">-</span></code>
<code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p>
</div></blockquote>
<p>Therefore, to include them as-is in a character set, the
backslash-escape must be used. For example, “<code class="docutils literal notranslate"><span class="pre">[\[\]\\]</span></code>” matches a
backslash or a square bracket.</p>
</section>
<section id="complementing-sets">
<h3>Complementing Sets<a class="headerlink" href="#complementing-sets" title="Link to this heading">¶</a></h3>
<p>Including “<code class="docutils literal notranslate"><span class="pre">^</span></code>” after the opening square bracket denotes the set
complement. Hence, “<code class="docutils literal notranslate"><span class="pre">[^abc]</span></code>” matches any code point except “<code class="docutils literal notranslate"><span class="pre">a</span></code>”,
“<code class="docutils literal notranslate"><span class="pre">b</span></code>”, and “<code class="docutils literal notranslate"><span class="pre">c</span></code>”. Here is an example where we seek any substring that
consists of 3 non-spaces.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;Nobody expects the Spanish Inquisition!&quot;</span>
<span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[^ ][^ ][^ ]&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;Nob&quot; &quot;ody&quot; &quot;exp&quot; &quot;ect&quot; &quot;the&quot; &quot;Spa&quot; &quot;nis&quot; &quot;Inq&quot; &quot;uis&quot; &quot;iti&quot; &quot;on!&quot;</span>
</pre></div>
</div>
</section>
<section id="defining-code-point-ranges">
<h3>Defining Code Point Ranges<a class="headerlink" href="#defining-code-point-ranges" title="Link to this heading">¶</a></h3>
<p>Each Unicode code point can be referenced by its unique numeric
identifier; see <a class="reference internal" href="input_output.html#sec-codepoints"><span class="std std-ref">Dealing with Unicode Code Points</span></a> for more details. For instance, “<code class="docutils literal notranslate"><span class="pre">a</span></code>” is
assigned code U+0061, and “<code class="docutils literal notranslate"><span class="pre">z</span></code>” is mapped to U+007A. In the pre-Unicode
era (mostly with regards to the ASCII codes, ≤ U+007F, representing
English letters, decimal digits, some punctuation characters, and a few
control characters), we were used to relying on specific code ranges;
e.g., “<code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>” denotes the set comprised of all characters with codes
between U+0061 and U+007A, i.e., lowercase letters of the English
(Latin) alphabet.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;In 2020, Gągolewski had fun once.&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[0-9A-Za-z]&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;I&quot; &quot;n&quot; &quot;2&quot; &quot;0&quot; &quot;2&quot; &quot;0&quot; &quot;G&quot; &quot;g&quot; &quot;o&quot; &quot;l&quot; &quot;e&quot; &quot;w&quot; &quot;s&quot; &quot;k&quot; &quot;i&quot; &quot;h&quot; &quot;a&quot; &quot;d&quot;</span>
<span class="c1">## [19] &quot;f&quot; &quot;u&quot; &quot;n&quot; &quot;o&quot; &quot;n&quot; &quot;c&quot; &quot;e&quot;</span>
</pre></div>
</div>
<p>The above pattern denotes a union of 3 code ranges: digits and ASCII
upper- and lowercase letters.</p>
<p>Nowadays, when processing text in natural languages, this notation
should be avoided. Note the missing “<code class="docutils literal notranslate"><span class="pre">ą</span></code>” (Polish “<code class="docutils literal notranslate"><span class="pre">a</span></code>” with
ogonek) in the result.</p>
</section>
<section id="using-predefined-character-sets">
<h3>Using Predefined Character Sets<a class="headerlink" href="#using-predefined-character-sets" title="Link to this heading">¶</a></h3>
<p>Each code point is assigned a unique general category, which can be
thought of as a character’s class, see
<a class="reference external" href="https://unicode.org/reports/tr44/">Unicode Standard Annex #44: {U}nicode Character Database</a>. Sets of characters
from each category can be referred to, amongst others, by using the
“<code class="docutils literal notranslate"><span class="pre">\p{category}</span></code>” (or, equivalently, “<code class="docutils literal notranslate"><span class="pre">[\p{category}]</span></code>”) syntax:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;aąbßÆAĄB你123,.;&#39;! \t-+=[]©←→”„²³¾&quot;</span>
<span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\p{L}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\p{Ll}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\p{Lu}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\p{N}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\p{P}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\p{S}&quot;</span><span class="p">)</span>
<span class="nf">structure</span><span class="p">(</span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="n">names</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="c1">## $`\\p{L}`</span>
<span class="c1">## [1] &quot;a&quot;  &quot;ą&quot;  &quot;b&quot;  &quot;ß&quot;  &quot;Æ&quot;  &quot;A&quot;  &quot;Ą&quot;  &quot;B&quot;  &quot;你&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{Ll}`</span>
<span class="c1">## [1] &quot;a&quot; &quot;ą&quot; &quot;b&quot; &quot;ß&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{Lu}`</span>
<span class="c1">## [1] &quot;Æ&quot; &quot;A&quot; &quot;Ą&quot; &quot;B&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{N}`</span>
<span class="c1">## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;²&quot; &quot;³&quot; &quot;¾&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{P}`</span>
<span class="c1">##  [1] &quot;,&quot; &quot;.&quot; &quot;;&quot; &quot;&#39;&quot; &quot;!&quot; &quot;-&quot; &quot;[&quot; &quot;]&quot; &quot;”&quot; &quot;„&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{S}`</span>
<span class="c1">## [1] &quot;+&quot; &quot;=&quot; &quot;©&quot; &quot;←&quot; &quot;→&quot;</span>
</pre></div>
</div>
<p>The above yield a match to: arbitrary letters, lowercase letters,
uppercase letters, numbers, punctuation marks, and symbols,
respectively.</p>
<p>Characters’ binary properties and scripts can also be referenced in a
similar manner. Some other noteworthy classes include:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\w&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\d&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\s&quot;</span><span class="p">)</span>
<span class="nf">structure</span><span class="p">(</span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="n">names</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="c1">## $`\\w`</span>
<span class="c1">##  [1] &quot;a&quot;  &quot;ą&quot;  &quot;b&quot;  &quot;ß&quot;  &quot;Æ&quot;  &quot;A&quot;  &quot;Ą&quot;  &quot;B&quot;  &quot;你&quot; &quot;1&quot;  &quot;2&quot;  &quot;3&quot; </span>
<span class="c1">## </span>
<span class="c1">## $`\\d`</span>
<span class="c1">## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\s`</span>
<span class="c1">## [1] &quot; &quot;  &quot;\t&quot;</span>
</pre></div>
</div>
<p>These give: word characters, decimal digits (”<code class="docutils literal notranslate"><span class="pre">\p{Nd}</span></code>”), and spaces
(”<code class="docutils literal notranslate"><span class="pre">[\t\n\f\r\p{Z}]</span></code>”), in this order.</p>
<p>Moreover, e.g., the upper-cased “<code class="docutils literal notranslate"><span class="pre">\P{category}</span></code>” and “<code class="docutils literal notranslate"><span class="pre">\W</span></code>” are
equivalent to “<code class="docutils literal notranslate"><span class="pre">[^\p{category}]</span></code>” and “<code class="docutils literal notranslate"><span class="pre">[^\w]</span></code>”, respectively, i.e.,
denote their complements.</p>
</section>
<section id="avoiding-posix-classes">
<h3>Avoiding POSIX Classes<a class="headerlink" href="#avoiding-posix-classes" title="Link to this heading">¶</a></h3>
<p>The use of the POSIX-like character classes should be avoided because
they are generally not well-defined.</p>
<p>In particular, in POSIX-like regex engines, “<code class="docutils literal notranslate"><span class="pre">[:punct:]</span></code>” stands for the
character class corresponding to the <code class="docutils literal notranslate"><span class="pre">ispunct()</span></code> function in C (see
“<code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">3</span> <span class="pre">ispunct</span></code>” on Unix-like systems). According to ISO/IEC 9899:1990
(ISO C90), <code class="docutils literal notranslate"><span class="pre">ispunct()</span></code> tests for any printing character except for the
space or a character for which <code class="docutils literal notranslate"><span class="pre">isalnum()</span></code> is true.</p>
<p>Base R with <em>PCRE</em> yields on the current author’s machine:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;,./|\\&lt;&gt;?;:&#39;\&quot;[]{}-=_+()*&amp;^%$€#@!`~×‒„”&quot;</span>
<span class="nf">regmatches</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nf">gregexpr</span><span class="p">(</span><span class="s">&quot;[[:punct:]]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">perl</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">))</span><span class="w">  </span><span class="c1"># base R</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;,&quot;  &quot;.&quot;  &quot;/&quot;  &quot;|&quot;  &quot;\\&quot; &quot;&lt;&quot;  &quot;&gt;&quot;  &quot;?&quot;  &quot;;&quot;  &quot;:&quot;  &quot;&#39;&quot;  &quot;\&quot;&quot; &quot;[&quot;  &quot;]&quot; </span>
<span class="c1">## [15] &quot;{&quot;  &quot;}&quot;  &quot;-&quot;  &quot;=&quot;  &quot;_&quot;  &quot;+&quot;  &quot;(&quot;  &quot;)&quot;  &quot;*&quot;  &quot;&amp;&quot;  &quot;^&quot;  &quot;%&quot;  &quot;$&quot;  &quot;#&quot; </span>
<span class="c1">## [29] &quot;@&quot;  &quot;!&quot;  &quot;`&quot;  &quot;~&quot;</span>
</pre></div>
</div>
<p>However, the details of the characters’ belongingness to this class
depend on the current locale. Therefore, the reader might obtain
different results when calling the above.</p>
<p><em>ICU</em>, on the other hand, always gives:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[[:punct:]]&quot;</span><span class="p">)</span><span class="w">    </span><span class="c1"># equivalently: \p{P}</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;,&quot;  &quot;.&quot;  &quot;/&quot;  &quot;\\&quot; &quot;?&quot;  &quot;;&quot;  &quot;:&quot;  &quot;&#39;&quot;  &quot;\&quot;&quot; &quot;[&quot;  &quot;]&quot;  &quot;{&quot;  &quot;}&quot;  &quot;-&quot; </span>
<span class="c1">## [15] &quot;_&quot;  &quot;(&quot;  &quot;)&quot;  &quot;*&quot;  &quot;&amp;&quot;  &quot;%&quot;  &quot;#&quot;  &quot;@&quot;  &quot;!&quot;  &quot;‒&quot;  &quot;„&quot;  &quot;”&quot;</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">[:punct:]</span></code> is merely a synonym for <code class="docutils literal notranslate"><span class="pre">\p{P}</span></code>. Further, <code class="docutils literal notranslate"><span class="pre">\p{S}</span></code>
captures symbols:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\p{S}&quot;</span><span class="p">)</span><span class="w">         </span><span class="c1"># symbols</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;|&quot; &quot;&lt;&quot; &quot;&gt;&quot; &quot;=&quot; &quot;+&quot; &quot;^&quot; &quot;$&quot; &quot;€&quot; &quot;`&quot; &quot;~&quot; &quot;×&quot;</span>
</pre></div>
</div>
<p>We strongly recommend, wherever possible, using the portable
“<code class="docutils literal notranslate"><span class="pre">[\p{P}\p{S}]</span></code>” as an alternative to the <em>PCRE</em>’s “<code class="docutils literal notranslate"><span class="pre">[:punct:]</span></code>”.</p>
</section>
</section>
<section id="alternating-and-grouping-subexpressions">
<h2>Alternating and Grouping Subexpressions<a class="headerlink" href="#alternating-and-grouping-subexpressions" title="Link to this heading">¶</a></h2>
<section id="alternation-operator">
<h3>Alternation Operator<a class="headerlink" href="#alternation-operator" title="Link to this heading">¶</a></h3>
<p>The alternation operator, “<code class="docutils literal notranslate"><span class="pre">|</span></code>”, matches either its left or its right
branch, for instance:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;spam, egg, ham, jam, algae, and an amalgam of spam, all al dente&quot;</span>
<span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam|ham&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;spam&quot; &quot;ham&quot;  &quot;spam&quot;</span>
</pre></div>
</div>
<p>“<code class="docutils literal notranslate"><span class="pre">|</span></code>” has very low precedence. Therefore, if we wish to introduce an
alternative of subexpressions, we need to group them, e.g., between
round brackets. For instance, “<code class="docutils literal notranslate"><span class="pre">(sp|h)am</span></code>” matches either “<code class="docutils literal notranslate"><span class="pre">spam</span></code>”
or “<code class="docutils literal notranslate"><span class="pre">ham</span></code>”.</p>
<p>Note that this has the side-effect of creating new capturing groups;
see <a class="reference internal" href="#sec-capturing"><span class="std std-ref">Capture Groups and References Thereto</span></a>.</p>
</section>
<section id="grouping-subexpressions">
<h3>Grouping Subexpressions<a class="headerlink" href="#grouping-subexpressions" title="Link to this heading">¶</a></h3>
<p>Also, matching is always done left-to-right, on a first-come,
first-served basis. So, if the left branch is a subset of the right
one, the latter will never be matched. In particular,
“<code class="docutils literal notranslate"><span class="pre">(al|alga|algae)</span></code>” can only match “<code class="docutils literal notranslate"><span class="pre">al</span></code>”. To fix this, we can write
“<code class="docutils literal notranslate"><span class="pre">(algae|alga|al)</span></code>”.</p>
</section>
<section id="non-grouping-parentheses">
<h3>Non-grouping Parentheses<a class="headerlink" href="#non-grouping-parentheses" title="Link to this heading">¶</a></h3>
<p>Some parenthesised subexpressions – those in which the opening bracket
is followed by the question mark – have a distinct meaning. In
particular, “<code class="docutils literal notranslate"><span class="pre">(?#...)</span></code>” denotes a free-format comment that is ignored by
the regex parser:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
<span class="w">  </span><span class="s">&quot;(?# match &#39;sp&#39; or &#39;h&#39;)(sp|h)(?# and &#39;am&#39;)am|(?# or match &#39;egg&#39;)egg&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;spam&quot; &quot;egg&quot;  &quot;ham&quot;  &quot;spam&quot;</span>
</pre></div>
</div>
<p>Nevertheless, constructing more sophisticated regexes by concatenating
subfragments thereof may sometimes be more readable:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
<span class="w">  </span><span class="nf">stri_join</span><span class="p">(</span>
<span class="w">      </span><span class="s">&quot;(sp|h)&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1"># match either &#39;sp&#39; or &#39;h&#39;</span>
<span class="w">      </span><span class="s">&quot;am&quot;</span><span class="p">,</span><span class="w">       </span><span class="c1"># followed by &#39;am&#39;</span>
<span class="w">    </span><span class="s">&quot;|&quot;</span><span class="p">,</span><span class="w">            </span><span class="c1"># ... or ...</span>
<span class="w">      </span><span class="s">&quot;egg&quot;</span><span class="w">       </span><span class="c1"># just match &#39;egg&#39;</span>
<span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;spam&quot; &quot;egg&quot;  &quot;ham&quot;  &quot;spam&quot;</span>
</pre></div>
</div>
<p>What is more, e.g., “<code class="docutils literal notranslate"><span class="pre">(?i)</span></code>” enables the <code class="docutils literal notranslate"><span class="pre">case_insensitive</span></code> mode.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_regex</span><span class="p">(</span><span class="s">&quot;Spam spam SPAMITY spAm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(?i)spam&quot;</span><span class="p">)</span>
<span class="c1">## [1] 4</span>
</pre></div>
</div>
</section>
</section>
<section id="quantifiers">
<h2>Quantifiers<a class="headerlink" href="#quantifiers" title="Link to this heading">¶</a></h2>
<p>More often than not, a variable number of instances of the same
subexpression needs to be captured, or its presence should be
optional. This can be achieved by means of the following quantifiers:</p>
<ul class="simple">
<li><p>“<code class="docutils literal notranslate"><span class="pre">?</span></code>” matches 0 or 1 times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">*</span></code>” matches 0 or more times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">+</span></code>” matches 1 or more times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n,m}</span></code>” matches between <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">m</span></code> times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n,}</span></code>” matches at least <code class="docutils literal notranslate"><span class="pre">n</span></code> times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n}</span></code>” matches exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</p></li>
</ul>
<p>These operators are applied to the preceding atoms. For example, “<code class="docutils literal notranslate"><span class="pre">ba+</span></code>”
captures <code class="docutils literal notranslate"><span class="pre">&quot;ba&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;baa&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;baaa&quot;</span></code>, etc., but neither <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code> alone
nor <code class="docutils literal notranslate"><span class="pre">&quot;bababa&quot;</span></code> altogether.</p>
<p>By default, the quantifiers are greedy – they match the repeated
subexpression as many times as possible. The “<code class="docutils literal notranslate"><span class="pre">?</span></code>” suffix (hence,
quantifiers such as “<code class="docutils literal notranslate"><span class="pre">??</span></code>”, “<code class="docutils literal notranslate"><span class="pre">*?</span></code>”, “<code class="docutils literal notranslate"><span class="pre">+?</span></code>”, and so forth) tries with as
few occurrences as possible (to obtain a match still).</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;sp(AM)(maps)(SP)am&quot;</span>
<span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\(.+\\)&quot;</span><span class="p">,</span><span class="w">    </span><span class="c1"># [[1]] greedy</span>
<span class="w">    </span><span class="s">&quot;\\(.+?\\)&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1"># [[2]] lazy</span>
<span class="w">    </span><span class="s">&quot;\\([^)]+\\)&quot;</span><span class="w">  </span><span class="c1"># [[3]] greedy (but clever)</span>
<span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;(AM)(maps)(SP)&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;(AM)&quot;   &quot;(maps)&quot; &quot;(SP)&quot;  </span>
<span class="c1">## </span>
<span class="c1">## [[3]]</span>
<span class="c1">## [1] &quot;(AM)&quot;   &quot;(maps)&quot; &quot;(SP)&quot;</span>
</pre></div>
</div>
<p>The first regex is greedy: it matches an opening bracket, then as many
characters as possible (including “<code class="docutils literal notranslate"><span class="pre">)</span></code>”) that are followed by a closing
bracket. The two other patterns terminate as soon as the first closing
bracket is found.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_first_regex</span><span class="p">(</span><span class="s">&quot;spamamamnomnomnomammmmmmmmm&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;sp(am|nom)+&quot;</span><span class="p">,</span><span class="w">             </span><span class="s">&quot;sp(am|nom)+?&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;sp(am|nom)+?m*&quot;</span><span class="p">,</span><span class="w">          </span><span class="s">&quot;sp(am|nom)+?m+&quot;</span><span class="p">))</span>
<span class="c1">## [1] &quot;spamamamnomnomnomam&quot;         &quot;spam&quot;                       </span>
<span class="c1">## [3] &quot;spam&quot;                        &quot;spamamamnomnomnomammmmmmmmm&quot;</span>
</pre></div>
</div>
<p>Let’s stress that the quantifier is applied to the subexpression that
stands directly before it. Grouping parentheses can be used in case they
are needed.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;12, 34.5, 678.901234, 37...629, ...&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\d+\\.\\d+&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\d+(\\.\\d+)?&quot;</span><span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;34.5&quot;       &quot;678.901234&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;12&quot;         &quot;34.5&quot;       &quot;678.901234&quot; &quot;37&quot;         &quot;629&quot;</span>
</pre></div>
</div>
<p>Here, the first regex matches digits, a dot, and another series of
digits. The second one finds digits that are possibly (but not
necessarily) followed by a dot and a digit sequence.</p>
<section id="performance-notes">
<h3>Performance Notes<a class="headerlink" href="#performance-notes" title="Link to this heading">¶</a></h3>
<p><em>ICU</em>, just like <em>PCRE</em>, uses a nondeterministic finite automaton-type
algorithm. Hence, due to backtracking, some ill-defined regexes can lead
to exponential matching times (e.g., “<code class="docutils literal notranslate"><span class="pre">(a+)+b</span></code>” applied on
<code class="docutils literal notranslate"><span class="pre">&quot;aaaa...aaaaac&quot;</span></code>). If such patterns are expected, setting the
<code class="docutils literal notranslate"><span class="pre">time_limit</span></code> or <code class="docutils literal notranslate"><span class="pre">stack_limit</span></code> option is recommended.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">system.time</span><span class="p">(</span><span class="nf">tryCatch</span><span class="p">({</span>
<span class="w">  </span><span class="nf">stri_detect_regex</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="o">%s*%</span><span class="w"> </span><span class="m">1000</span><span class="w"> </span><span class="o">%s+%</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(a+)+b&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">time_limit</span><span class="o">=</span><span class="m">1e5</span><span class="p">)</span>
<span class="p">},</span><span class="w"> </span><span class="n">error</span><span class="o">=</span><span class="kr">function</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="nf">cat</span><span class="p">(</span><span class="s">&quot;stopped.&quot;</span><span class="p">)))</span>
<span class="c1">## stopped.</span>
<span class="c1">##    user  system elapsed </span>
<span class="c1">##  11.135   0.000  11.135</span>
</pre></div>
</div>
<p>Nevertheless, oftentimes such regexes can be naturally reformulated to
fix the underlying issue. The <em>ICU</em> User Guide on Regular Expressions
also recommends using possessive quantifiers (”<code class="docutils literal notranslate"><span class="pre">?+</span></code>”, “<code class="docutils literal notranslate"><span class="pre">*+</span></code>”, “<code class="docutils literal notranslate"><span class="pre">++</span></code>”,
and so on), which match as many times as possible but, contrary to the
plain-greedy ones, never backtrack when they happen to consume too much
data.</p>
<p>See also the documentation of
the <a class="reference external" href="https://github.com/qinwf/re2r"><em>re2r</em></a>
and <a class="reference external" href="https://github.com/girishji/re2/"><em>re2</em></a>
(wrappers around the <a class="reference external" href="https://github.com/google/re2"><em>RE2</em></a>
library) packages and the references therein for a discussion.</p>
</section>
</section>
<section id="capture-groups-and-references-thereto">
<span id="sec-capturing"></span><h2>Capture Groups and References Thereto<a class="headerlink" href="#capture-groups-and-references-thereto" title="Link to this heading">¶</a></h2>
<p>Round-bracketed subexpressions carry one additional characteristic: they
form the so-called capture groups that can be extracted separately or be
referred to in other parts of the same regex.</p>
<section id="extracting-capture-group-matches">
<h3>Extracting Capture Group Matches<a class="headerlink" href="#extracting-capture-group-matches" title="Link to this heading">¶</a></h3>
<p>The above is evident when we use the versions of <code class="docutils literal notranslate"><span class="pre">stri_extract()</span></code> that
are sensitive to the presence of capture groups:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;name=&#39;Sir Launcelot&#39;, quest=&#39;Seek the Grail&#39;, favecolour=&#39;blue&#39;&quot;</span>
<span class="nf">stri_match_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(\\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##      [,1]                     [,2]         [,3]            </span>
<span class="c1">## [1,] &quot;name=&#39;Sir Launcelot&#39;&quot;   &quot;name&quot;       &quot;Sir Launcelot&quot; </span>
<span class="c1">## [2,] &quot;quest=&#39;Seek the Grail&#39;&quot; &quot;quest&quot;      &quot;Seek the Grail&quot;</span>
<span class="c1">## [3,] &quot;favecolour=&#39;blue&#39;&quot;      &quot;favecolour&quot; &quot;blue&quot;</span>
</pre></div>
</div>
<p>The findings are presented in a matrix form. The first column gives the
complete matches, the second column stores the matches to the first
capture group, and so forth.</p>
<p>If we just need the grouping part of “<code class="docutils literal notranslate"><span class="pre">(...)</span></code>”, i.e., without the
capturing feature, “<code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>” can be applied. Also, named capture
groups defined like “<code class="docutils literal notranslate"><span class="pre">(?&lt;name&gt;...)</span></code>” are fully supported since version
1.7.1 of our package (for historical notes see <span id="id9">[<a class="reference internal" href="../z_bibliography.html#id31" title="Hocking, T.D. (2019).  Comparing namedCapture with other R packages for regular expressions. The R Journal, 11/2:328–346.">4</a>]</span>).</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_match_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(?:\\w+)=&#39;(?&lt;value&gt;.+?)&#39;&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##                               value           </span>
<span class="c1">## [1,] &quot;name=&#39;Sir Launcelot&#39;&quot;   &quot;Sir Launcelot&quot; </span>
<span class="c1">## [2,] &quot;quest=&#39;Seek the Grail&#39;&quot; &quot;Seek the Grail&quot;</span>
<span class="c1">## [3,] &quot;favecolour=&#39;blue&#39;&quot;      &quot;blue&quot;</span>
</pre></div>
</div>
</section>
<section id="locating-capture-group-matches">
<h3>Locating Capture Group Matches<a class="headerlink" href="#locating-capture-group-matches" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">capture_groups</span></code> attribute in <code class="docutils literal notranslate"><span class="pre">stri_locate__regex</span></code> enables us to
pinpoint the matches to the parenthesised subexpressions as well:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_locate_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(?&lt;key&gt;\\w+)=&#39;(?&lt;value&gt;.+?)&#39;&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="n">capture_groups</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">get_length</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##      start length</span>
<span class="c1">## [1,]     1     20</span>
<span class="c1">## [2,]    23     22</span>
<span class="c1">## [3,]    47     17</span>
<span class="c1">## attr(,&quot;capture_groups&quot;)</span>
<span class="c1">## attr(,&quot;capture_groups&quot;)$key</span>
<span class="c1">##      start length</span>
<span class="c1">## [1,]     1      4</span>
<span class="c1">## [2,]    23      5</span>
<span class="c1">## [3,]    47     10</span>
<span class="c1">## </span>
<span class="c1">## attr(,&quot;capture_groups&quot;)$value</span>
<span class="c1">##      start length</span>
<span class="c1">## [1,]     7     13</span>
<span class="c1">## [2,]    30     14</span>
<span class="c1">## [3,]    59      4</span>
</pre></div>
</div>
<p>Note that each item in the resulting list is equipped with a
<code class="docutils literal notranslate"><span class="pre">&quot;capture_groups&quot;</span></code> attribute. For instance,
<code class="docutils literal notranslate"><span class="pre">attr(result[[1]],</span> <span class="pre">&quot;capture_groups&quot;)[[2]]</span></code> extracts the locations of the
matches to the 2nd capture group in the first input string.</p>
</section>
<section id="replacing-with-capture-group-matches">
<h3>Replacing with Capture Group Matches<a class="headerlink" href="#replacing-with-capture-group-matches" title="Link to this heading">¶</a></h3>
<p>Matches to particular capture groups can be recalled in replacement
strings when using <code class="docutils literal notranslate"><span class="pre">stri_replace()</span></code>. Here, the match in its entirety is
denoted with “<code class="docutils literal notranslate"><span class="pre">$0</span></code>”, then “<code class="docutils literal notranslate"><span class="pre">$1</span></code>” stores whatever was caught by the first
capture group, “<code class="docutils literal notranslate"><span class="pre">$2</span></code>” is the match to the second capture group, etc.
Moreover, “<code class="docutils literal notranslate"><span class="pre">\$</span></code>” gives the dollar-sign.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_replace_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(\\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;$2 is a $1&quot;</span><span class="p">)</span>
<span class="c1">## [1] &quot;Sir Launcelot is a name, Seek the Grail is a quest, blue is a favecolour&quot;</span>
</pre></div>
</div>
<p>Named capture groups can be referred to too:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_replace_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(?&lt;key&gt;\\w+)=&#39;(?&lt;value&gt;.+?)&#39;&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="s">&quot;${value} is a ${key}&quot;</span><span class="p">)</span>
<span class="c1">## [1] &quot;Sir Launcelot is a name, Seek the Grail is a quest, blue is a favecolour&quot;</span>
</pre></div>
</div>
</section>
<section id="back-referencing">
<h3>Back-Referencing<a class="headerlink" href="#back-referencing" title="Link to this heading">¶</a></h3>
<p>Matches to capture groups can also be part of the regexes themselves.
For example, “<code class="docutils literal notranslate"><span class="pre">\1</span></code>” denotes whatever has been consumed by the first
capture group.</p>
<p>Even though, in general, parsing HTML code with regexes is not
recommended, let us consider the following examples:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;eggs&lt;/code&gt;&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;&lt;[a-z]+&gt;.*?&lt;/[a-z]+&gt;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&lt;([a-z]+)&gt;.*?&lt;/\\1&gt;&quot;</span><span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&quot; &quot;&lt;code&gt;eggs&lt;/code&gt;&quot;    </span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&lt;/strong&gt;&quot; &quot;&lt;code&gt;eggs&lt;/code&gt;&quot;</span>
</pre></div>
</div>
<p>The second regex guarantees that the match will include all characters
between the opening <code class="docutils literal notranslate"><span class="pre">&lt;tag&gt;</span></code> and the corresponding (not: any) closing
<code class="docutils literal notranslate"><span class="pre">&lt;/tag&gt;</span></code>. Named capture groups can be referenced using the <code class="docutils literal notranslate"><span class="pre">\k&lt;name&gt;</span></code>
syntax (the angle brackets are part of the token), as in, e.g.,
“<code class="docutils literal notranslate"><span class="pre">&lt;(?&lt;tagname&gt;[a-z]+)&gt;.*?&lt;/\k&lt;tagname&gt;&gt;</span></code>”.</p>
</section>
</section>
<section id="anchoring">
<h2>Anchoring<a class="headerlink" href="#anchoring" title="Link to this heading">¶</a></h2>
<p>Lastly, let’s mention how to match a pattern at a given abstract
position within a string.</p>
<section id="matching-at-the-beginning-or-end-of-a-string">
<h3>Matching at the Beginning or End of a String<a class="headerlink" href="#matching-at-the-beginning-or-end-of-a-string" title="Link to this heading">¶</a></h3>
<p>“<code class="docutils literal notranslate"><span class="pre">^</span></code>” and “<code class="docutils literal notranslate"><span class="pre">$</span></code>” match, respectively, the start and the end of the string (or
each line within a string, if the <code class="docutils literal notranslate"><span class="pre">multi_line</span></code> option is set to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>).</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;spam egg&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bacon spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;egg spam bacon&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;sausage&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;^spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam$&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam$|^spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;^spam$&quot;</span><span class="p">)</span>
<span class="nf">structure</span><span class="p">(</span><span class="nf">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">stri_detect_regex</span><span class="p">),</span><span class="w"> </span><span class="n">dimnames</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">))</span>
<span class="c1">##                 spam ^spam spam$ spam$|^spam ^spam$</span>
<span class="c1">## spam egg        TRUE  TRUE FALSE        TRUE  FALSE</span>
<span class="c1">## bacon spam      TRUE FALSE  TRUE        TRUE  FALSE</span>
<span class="c1">## spam            TRUE  TRUE  TRUE        TRUE   TRUE</span>
<span class="c1">## egg spam bacon  TRUE FALSE FALSE       FALSE  FALSE</span>
<span class="c1">## sausage        FALSE FALSE FALSE       FALSE  FALSE</span>
</pre></div>
</div>
<p>The 5 regular expressions match “<code class="docutils literal notranslate"><span class="pre">spam</span></code>”, respectively, anywhere within
the string, at the beginning, at the end, at the beginning or end, and
in strings that are equal to the pattern itself.</p>
</section>
<section id="matching-at-word-boundaries">
<h3>Matching at Word Boundaries<a class="headerlink" href="#matching-at-word-boundaries" title="Link to this heading">¶</a></h3>
<p>Furthermore, “<code class="docutils literal notranslate"><span class="pre">\b</span></code>” matches at a “word boundary”, e.g., near spaces,
punctuation marks, or at the start/end of a string (i.e., wherever there
is a transition between a word, “<code class="docutils literal notranslate"><span class="pre">\w</span></code>”, and a non-word character,
“<code class="docutils literal notranslate"><span class="pre">\W</span></code>”, or vice versa).</p>
<p>In the following example, we match all stand-alone numbers
(this regular expression is provided for didactic purposes only):</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;12, 34.5, J23, 37.629cm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\b\\d+(\\.\\d+)?+\\b&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;12&quot;   &quot;34.5&quot;</span>
</pre></div>
</div>
<p>Note the possessive quantifier, “<code class="docutils literal notranslate"><span class="pre">?+</span></code>”: try matching a dot and a
sequence of digits, and if it’s present but not followed by a word
boundary, do not retry by matching a word boundary only.</p>
</section>
<section id="looking-behind-and-ahead">
<h3>Looking Behind and Ahead<a class="headerlink" href="#looking-behind-and-ahead" title="Link to this heading">¶</a></h3>
<p>There are also ways to guarantee that a pattern occurrence begins or
ends with a match to some subexpression: “<code class="docutils literal notranslate"><span class="pre">(?&lt;=...)...</span></code>” is the
so-called look-behind, whereas “<code class="docutils literal notranslate"><span class="pre">...(?=...)</span></code>” denotes the look-ahead.
Moreover, “<code class="docutils literal notranslate"><span class="pre">(?&lt;!...)...</span></code>” and “<code class="docutils literal notranslate"><span class="pre">...(?!...)</span></code>” are their negated
(“negative look-behind/ahead”) versions.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;I like spam, spam, eggs, and spam.&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\w+(?=[,.])&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\\w++(?![,.])&quot;</span><span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;spam&quot; &quot;spam&quot; &quot;eggs&quot; &quot;spam&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;I&quot;    &quot;like&quot; &quot;and&quot;</span>
</pre></div>
</div>
<p>The first regex captures words that end with “<code class="docutils literal notranslate"><span class="pre">,</span></code>” or “<code class="docutils literal notranslate"><span class="pre">.</span></code>”. The second
one matches words that end neither with “<code class="docutils literal notranslate"><span class="pre">,</span></code>” nor “<code class="docutils literal notranslate"><span class="pre">.</span></code>”.</p>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footequivalent" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">1</a><span class="fn-bracket">]</span></span>
<p>This does not mean, though, that it considers canonically
equivalent strings as equal, see <a class="reference internal" href="collation.html#sec-equivalence"><span class="std std-ref">Testing String Equivalence</span></a> for
discussion and a workaround.</p>
</aside>
</aside>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="collation.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Collation</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="codepoint_comparing.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Code-Pointwise Comparing</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
              
              
              Copyright &#169; 2013–2025 by <a href="https://www.gagolewski.com">Marek Gagolewski</a>.
              Some rights reserved. Licensed under <a href='https://creativecommons.org/licenses/by-nc-nd/4.0/'>CC BY-NC-ND 4.0</a>.
              Built with <a href="https://sphinx-doc.org/">Sphinx</a>
              and a customised <a href="https://github.com/pradyunsg/furo">Furo</a> theme.
              Last updated on 2025-03-25T16:08:37+0100.
              This site will never display any ads: it is a non-profit project.
              It does not collect any data.
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            In this section
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Regular Expressions</a><ul>
<li><a class="reference internal" href="#matching-individual-characters">Matching Individual Characters</a><ul>
<li><a class="reference internal" href="#matching-any-character">Matching Any Character</a></li>
<li><a class="reference internal" href="#defining-character-sets">Defining Character Sets</a></li>
<li><a class="reference internal" href="#complementing-sets">Complementing Sets</a></li>
<li><a class="reference internal" href="#defining-code-point-ranges">Defining Code Point Ranges</a></li>
<li><a class="reference internal" href="#using-predefined-character-sets">Using Predefined Character Sets</a></li>
<li><a class="reference internal" href="#avoiding-posix-classes">Avoiding POSIX Classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternating-and-grouping-subexpressions">Alternating and Grouping Subexpressions</a><ul>
<li><a class="reference internal" href="#alternation-operator">Alternation Operator</a></li>
<li><a class="reference internal" href="#grouping-subexpressions">Grouping Subexpressions</a></li>
<li><a class="reference internal" href="#non-grouping-parentheses">Non-grouping Parentheses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quantifiers">Quantifiers</a><ul>
<li><a class="reference internal" href="#performance-notes">Performance Notes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#capture-groups-and-references-thereto">Capture Groups and References Thereto</a><ul>
<li><a class="reference internal" href="#extracting-capture-group-matches">Extracting Capture Group Matches</a></li>
<li><a class="reference internal" href="#locating-capture-group-matches">Locating Capture Group Matches</a></li>
<li><a class="reference internal" href="#replacing-with-capture-group-matches">Replacing with Capture Group Matches</a></li>
<li><a class="reference internal" href="#back-referencing">Back-Referencing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#anchoring">Anchoring</a><ul>
<li><a class="reference internal" href="#matching-at-the-beginning-or-end-of-a-string">Matching at the Beginning or End of a String</a></li>
<li><a class="reference internal" href="#matching-at-word-boundaries">Matching at Word Boundaries</a></li>
<li><a class="reference internal" href="#looking-behind-and-ahead">Looking Behind and Ahead</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=daef7da6"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=4e2eecee"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>